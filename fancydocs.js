registerProject({"title":"smocks","summary":"Stateful HTTP mocking service built on top of [HAPI](http://hapijs.com/).  Easily add routes and different scenarios for each route including the ability to maintain state with an admin interface to control everything.\n\nWith smocks you can\n\n* create route definitions (with dynamic tokens)\n* define multiple route handlers (variants) for for any route (selectable through an admin panel)\n* add input configuration components for routes and variants (accessable through an admin panel)\n* define actions which can manipulate the current state and be executed from the admin pnael\n* use route request handlers that can keep a state for true dynamic mocking capabilities\n* define global request handlers (variants) which can be selected for any route\n* use plugins which can intercept all requests to perform actions\n* use a RESTful API to make configuration changes programatically\n* Replay exports from HAR files\n* be able to use as a direct proxy to real service endpoints","sections":[{"body":"After you define your fixtures, you will want to start the server (or you can actually refer to your fixtures with an API if you want to use with unit tests).\n\nThere are 2 ways to start the server:\n\nStarting the server directly\n```\nrequire('smocks/hapi').start({\n  // options provided to Hapi.Server.start\n  port: 8080,\n  host: 'localhost'\n}, {\n  // smocks init options\n});\n```\n\nOr, you can just export a Hapi plugin to be included elsewhere\n```\nvar plugin = require('smocks/hapi').toPlugin({\n  // hapi plugin options\n  onRegister: function (server, options, next) {\n    // this is optional but \"next\" must be called if used\n  }\n}, {\n  // smocks init options\n});\n\nplugin.attributes = {\n  pkg: require('/path/to/package.json')\n};\n\nmodule.exports = plugin;\n```\n\nThe different smocks core options are discussed in detail below.","title":"Starting the server","sections":[]},{"body":"| Attribute | value |\n|-----------|-------|\n| initialState | (optional) the initial application state that should be applied when first loaded (or reset)\n| har | see ***HTTP Archive Replay***\n| proxy | see ***Proxying***","title":"Smocks init options","sections":[]},{"body":"","title":"Concepts","sections":[{"body":"Whenever the mock server is running, you can view an admin panel at ```{host}:{port}```.  Using this, you can\n\n* Select what type of response your routes should have (see [Variants](#link/%23section%2FConcepts%2FVariants))\n* Execute route specific actions (see Actions)\n* View all available routes by label or path\n* Set route specific or global input fields (see [Route / Variant Input](#link/%23section%2FConcepts%2FRoute%252520%25252F%252520variant%252520input))\n* Save all current settings as a profile (selected route variant and input values) to be applied at a later time (see [Profiles](#link/%23section%2FConcepts%2FProfiles))\n\nThroughout these docs, you will see different screenshots to understand how different route configurations are represented in the admin panel.","title":"Admin Panel","sections":[]},{"body":"A route by itself is really nothing more than a [HAPI route](http://hapijs.com/api#serverrouteoptions).  The route definition has a ```handler``` attribute which is called when the endpoint is hit.  This handler is nothing more than a [HAPI route handler](http://hapijs.com/api#route-handler).\n\nRoutes are defined using the ```route``` method on the ```smocks``` object.  An object parameter is provided with the following attributes\n\n* _id_: (optional) the route id - used for the RESTful admin API and profile settings\n* _label_: (optional) the route label - used for display on the admin panel\n* _path_: the route path\n* _method_: (optional) the route method - defaults to ```GET```\n* _group_: (optional) arbitrary group name to organize routes in the admin panel\n* _handler_: (optional) the [HAPI route handler](http://hapijs.com/api#route-handler) which provides the route response.  This is optional because you could use multiple vairants to handle the response.  (see Variants).\n* _input_: An object contain input values which should be shown in the admin panel (see Input)\n* _display_: A function which can return [markdown]([markdown](http://daringfireball.net/projects/markdown/)) where the contents are exposed when viewing the route information on the amin panel\n* _actions_: An object containing a set of actions associated with this route (see Actions)\n* _config_: [HAPI route options](http://hapijs.com/api#route-options)\n* _connection_: optional connection label for route to be added to. allows\n  for smocks endpoint to run on port of choice, for instance.\n\nIn more detail, you can...\n\nOrganize your routes into logical groups\n```javascript\n    smocks.route({\n      id: 'group_1_1',\n      group: 'group 1',\n      path: '/api/group/1/1',\n\n      handler: function (req, reply) {\n        reply('I\\'m in group 1');\n      }\n    })\n    .route({\n      id: 'group_1_2',\n      group: 'group 1',\n      path: '/api/group/1/2',\n\n      handler: function (req, reply) {\n        reply('I\\'m also in group 1');\n      }\n    })\n\n    .route({\n      id: 'group_2_1',\n      group: 'group 2',\n      path: '/api/group/2/1',\n\n      handler: function (req, reply) {\n        reply('I\\'m in group 2');\n      }\n    })\n    .route({\n      id: 'group_2_2',\n      group: 'group 2',\n      path: '/api/group/2/2',\n\n      handler: function (req, reply) {\n        reply('I\\'m also in group 2');\n      }\n    });\n```\n\n![groups](http://jhudson8.github.io/smocks/images/groups.png)\n\n\nAdd input parameters that are exposed through the admin panel\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({\n      // labels aren't required but make things easier to view in the admin panel for non-technical people\n      id: 'my_route',\n      label: 'My Route',\n      path: '/api/foo',\n      method: 'GET',\n\n      input: {\n        // more about config later\n        agreementAccepted: {\n          label: 'agreement accepted?',\n          type: 'boolean',\n          defaultValue: false\n        }\n      },\n\n      handler: function(request, reply) {\n        // you can control this value through the admin panel\n        var agreementAccepted = this.input('agreementAccepted');\n        reply({accepted: agreementAccepted});\n      }\n    })\n```\n\n![route ex1](http://jhudson8.github.io/smocks/images/route-ex1.png)\n\n\nProvide multiple response types for each route (called Variants).  With the variants below, you can select which type of response the ```/api/foo``` route should respond with in the admin panel.  More about variants later...\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({\n      id: 'my_route',\n      path: '/api/foo',\n      handler: function(request, reply) {\n        // this is essentially the same as the \"default\" variant\n        reply({firstName: 'John'});\n      }\n    })\n    .variant({\n      // in this case the label really isn't necesary since it would be the same as the id\n      id: 'Billy',\n      handler: function(request, reply) {\n        reply({firstName: 'Billy'});\n      }\n    })\n    .variant({\n      // in this case the label really isn't necesary since it would be the same as the id\n      id: 'Clark',\n      handler: function(request, reply) {\n        reply({firstName: 'Billy'});\n      }\n    })\n```\n\n![route ex2](http://jhudson8.github.io/smocks/images/route-ex2.png)\n\n\nYou can provide a display value which will be used when viewing the route details in the admin panel.  We haven't discussed state yet but this is meaningful to represent the current state of things for quick glance in the admin panel.  The admin panel supports [markdown](http://daringfireball.net/projects/markdown/) for your display response.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({\n      // ...\n      display: function() {\n        return '* this will show up as a unordered list';\n      }\n    })\n```\n\n![route ex3](http://jhudson8.github.io/smocks/images/route-ex3.png)\n\n\nYou can expose \"actions\" which are represented as buttons.  These are meaningful to quickly make changes to the state of things.  Actions, like routes and variants, can accept config parameters which will allow you to input data required to perform the action.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({\n      // ...\n      input: {\n        yourPhoneNumber: {\n          label: 'What is your phone number?',\n          type: 'text',\n          defaultValue: '999.867.5309'\n        }\n      },\n\n      // now define our action for the previous route\n      actions: {\n        'the_action_id': {\n          label: 'the button label',\n          input: {\n            yourName: {\n              label: 'What is your name?',\n              type: 'text',\n              defaultValue: 'John Doe'\n            }\n          },\n          handler: function(input) {\n            // this is how you access action specific user input\n            var yourName = input.yourName;\n            // this is how you access user input created for the route\n            var phoneNumber = this.input('yourPhoneNumber');\n            // now I would perform whatever action needs to be taken\n            // I would make changes to \"state\" most likely (more about state later)\n          }\n        }\n      }\n    })\n```\n\n![route ex4](http://jhudson8.github.io/smocks/images/route-ex4.png)\n\nYou can use dynamic parameters in the route path, get access to query parameters and the body payload.  See [path parameters](http://hapijs.com/api#path-parameters) for more details.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({\n      path: '/api/customer/{id}'\n      handler: function(config) {\n        // would be \"123\" if the endpiont hit was \"/api/customer/123\"\n        var id = request.params.id;\n\n        // would be \"bar\" if the endpoint hit was \"/api/customer/123?foo=bar\"\n        var foo = request.query.foo;\n\n        // would be \"bar\" if the posted body content (as JSON) was {\"foo\": \"bar\"}\n        var foo = request.payload.foo;\n      }\n    })\n```","title":"Routes","sections":[]},{"body":"We briefly touch on variants when discussing routes but variants are route handlers that can be selected by you in the admin panel (or with a RESTful API) to determine what type of response a route should have.\n\nRoutes are defined using the ```variant``` method on the ```Route``` object (returned by calling the ```route``` method.  An object parameter is provided with the following attributes\n\n* _id_: (optional) the route id - used for the RESTful admin API and profile settings\n* _label_: (optional) the route label - used for display on the admin panel\n* _input_: An object contain input configuration data to be shown in the admin panel (see Input)\n* _handler_: (optional) the [HAPI route handler](http://hapijs.com/api#route-handler) which provides the route response\n\nVariants are useful because they allow yout test multiple scenarios that can happen with your route.  Say, for example, you have a route exposing the ability to update a password.  You might have several exceptional scenarios that you would want to test out (each could be a vairant that you simply select to tell the route handler to use the appropriate response)\n\n* the password was reset successfully\n* the password didn't pass validation\n* the old password wasn't entered correctly\n* the username doesn't exist\n* and so on...\n\nIn more detail, you can...\n\nHave multiple variants associated with a single route\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({...})\n\n      .variant(...)\n\n      .variant(...)\n\n      .variant(...)\n```\n\n\nAdd variant specific config parameters (only visible if the variant is selected as the active variant) that are exposed through the admin panel\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({...})\n\n      .variant({\n        id: 'invalid_password',\n        label: 'invalid password',\n        handler: function(request, reply) {\n          // the input value is retrieved using this.input('varName');\n          var typeOfValidationError = this.input('typeOfValidationError')\n          reply({error: 'field', message: typeOfValidationError}).code(400);\n        },\n        input: {\n          // the key is the identifier used to retrieve the value\n          typeOfValidationError: {\n            // the input field label\n            label: 'What type of validation error?',\n            // type can be \"boolean\", \"text\", \"select\", \"multiselect\"\n            type: 'text',\n            // the value shown if no selection has been made\n            defaultValue: 'password too short'\n          }\n        }\n      })\n```","title":"Variants","sections":[]},{"body":"Different types of input fields can be defined for routes or variants including ```boolean```, ```text```, ```select```, ```multiselect```.  Through the admin panel, you can modify these input values and they can be accessed in your route handler.\n\nRoutes and Variants when defined can provide an optional ```input``` attribute which defines any input fields that should be shown in the admin panel.  This input attribute is an object with each attribute relating to a single input field and the associated key as the input field id.\n\nThe attributes for each input field setting are\n\n* _label_: the input field label\n* _type_: the input field type (```boolean|text|select|multiselect```)\n* _defaultValue_: the value for the input field when the user has not yet made a selection in the admin panel\n* _options_: (specific to ```select``` and ```multiselect```) an array of options for the input field.  Each element in the array is an object with a ```value``` and ```label``` attribute.\n\nInput values are referenced using ```this.input('varName')``` where ```varName``` is the specific input attribute key.\n\n```javascript\n    smock.route({\n      ...\n      input: {\n        aBooleanField: {\n          label: 'Is this a checkbox?',\n          type: 'boolean',\n          defaultValue: true\n        },\n        someTextField: {\n          label: 'A text field',\n          type: 'text',\n          defaultValue: 'Hello'\n        },\n        someSelectBox: {\n          label: 'A select box',\n          type: 'select',\n          options: [{label: 'One', value: 1}, {label: 'Two', value: 2}, {label: 'Three', value: 3}],\n          defaultValue: 2\n        },\n        someMultiSelect: {\n          label: 'A check list',\n          type: 'multiselect',\n          options: [{label: 'One', value: 1}, {label: 'Two', value: 2}, {label: 'Three', value: 3}],\n          defaultValue: [2, 3]\n        }\n      },\n      handler: function(request, response) {\n        var aBooleanField = this.input('aBooleanField'); // boolean\n        var someTextField = this.input('someTextField'); // string\n        var someSelectBox = this.input('someSelectBox'); // integer (because the values are integers)\n        var someMultiSelect = this.input('someMultiSelect'); // array of integer (because the values are integers)\n        // ...\n      });\n```\n\n![input example](http://jhudson8.github.io/smocks/images/config-ex1.png)\n\nThe same ```config``` values can be applied at the variant level as well.","title":"Route / variant input","sections":[]},{"body":"This is similar to Route / variant input except that these values are not exposed within the admin console.  They are accessable within the route handlers though.\n\nThis is mostly useful for global plugins (see Plugins).\n\nWithin the route handler, the options values can be accessed by using ```this.meta('varName')```.\n\n```javascript\n    var smocks = require('smocks');\n\n    smocks.route({\n      ...\n      meta: {\n        requiresLogin: true\n      },\n      handler: function(request, reply) {\n        // this doesn't make a lot of sense because the value is defined here\n        // but would actually make more sense as a plugin... this is just showing\n        // how you would (and could) get the meta value in a route handler\n        var value = this.meta('requiresLogin');\n        ...\n      }\n    );\n```","title":"Route meta data","sections":[]},{"body":"The real benefit to using ```smocks``` is that state can be maintained.  Within any response handler, use ```this.state('varName')``` to access an object stored in the state and ```this.state('varName', 'varValue')``` where ```varValue``` can be any type of object you want.  There is a button on the admin panel which allows you to reset the state and start over.\n\n```javascript\n    var smocks = require('smocks');\n\n    smocks.route({\n      route: '/api/login',\n      method: 'POST',\n      handler: function(request, reply) {\n        // now you can use this.state('loggedIn') in any route handler to see if the user has logged in\n        this.state('loggedIn', true);\n        reply().code(204);\n      }\n    });\n```","title":"State","sections":[]},{"body":"This has been discussed previously, but to have all handler context methods in a single place (things referenced using `this.`) in your handlers\n\n| Attribute | Description |\n|-----------|-------------|\n| state | see ***State***\n| meta | see ***Meta***\n| input | see ***Input***\n| route | the current `route object`\n| variant | the currently selected `variant object`","title":"Route / variant / plugin handlers","sections":[]},{"body":"There are 3 different ways of introducting dynamic behavior into your responses but each serve a different purpose.\n\n_input_\n\nInput values are exposed as input fields in the admin panel so you have the ability to change the value at runtime.\n\nThese are accessed using ```this.input('varName')``` in any route handler.\n\n_state_\n\nState is used to, obviously, maintain state.  For example, if you expose a route that adds a new piece of data, you should store it in state.  The user can reset the state with a button on the admin panel.\n\nState values can be accessed using ```this.state('varName')```.\nState values can be set using ```this.state('varName', 'value')```.\n\n_meta_\n\nMeta settings are like config but are not exposed in the admin panel.  These are most useful to expose metadata for a global pugin.  For example, you could have a plugin that examined all requests and, if the user hasn't signed in yet, respond with a 401 error.  The routes could expose a meta value that indicated whether they were routes that required authentication.\n\nThese are accessed using ```this.meta('varName')```.","title":"Input, state and meta, oh my","sections":[]},{"body":"Plugins can be used to perform an action on all requests or just to encapsulate a set of route handlers.  Plugins can have config values just like Routes or Variants.\n\nPlugins are just simple objects that have the following attributes\n\n* _plugin_: (optional) if exists, will simply be called with a single parameter (the smocks object) so you can add new routes.\n* _input_: (optional) input definitions to allow the user with different types of input fields in the admin panel.  See the next section (Input types) for more details\n* _onRequest_: Called before the route handler (variant) executes for every request.  It is similar to the ([request, reply](http://hapijs.com/api#route-handler)) of the route handlers (Variants) but has an additional callback method that should be executed when the plugin has finished doing what it needs to do.\n\n* _onResponse_: Called after the route handler (variant) executes for every request.  Parameters are similar to ```onRequest``` except the 2nd parameter is the return value from the [reply method (see response object)](http://hapijs.com/api#reply-interface).\n\nThe following plugin will add simulated latency (which can be controlled by the user) to all requests.\n\n```\n    var smocks = require('smocks');\n    smocks.plugin({\n      // define the input field for the admin panel allowing the user to adjust the delay\n        input: {\n          delay: {\n            label: 'Add delay to all responses',\n            type: 'select',\n            options: [{label: 'no delay', value: 0}, {label: '1 sec', value: 1000}, {label: '5 sec', value: 5000}],\n            defaultValue: 0\n          }\n        },\n\n        // call \"next\" after a timeout if the user requested a delay\n        onRequest: function(request, reply, next) {\n          // get the delay value from config\n          var delay = this.input('delay');\n          if (delay > 0) {\n            // if there is a delay, call next after a timeout\n            setTimeout(next, delay);\n          } else {\n            next();\n          }\n        },\n\n        onResponse: function(request, response) {\n          // I can do things to the response here\n          response.code(404);\n        }\n      })\n```\n\n![plugin example](http://jhudson8.github.io/smocks/images/plugin-ex1.png)\n\nOr, check to see if the use has logged in (assuming the route exposed a ```requiresLogin``` option; see Route Options).  We are using state (see State) to track if the login endpoing has been hit prior to the current route.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.plugin({\n      onRequest: function(request, reply, next) {\n        // only do this check if the route exposed a \"requiresLogin\" option\n        if (this.meta('requiresLogin')) {\n          // now, see if we have previously logged in (the login route would have set this state value)\n          if (!this.state('loggedIn')) {\n            // if we haven't logged respond with a 401 and bypass calling \"next\"\n            return reply({error: 'auth', message: 'Not logged in'}).code(401);\n          }\n        }\n\n        next();\n      }\n    });\n```","title":"Plugins","sections":[]},{"body":"Smocks can use one or more connections for where to set endpoints. The main\nendpoints are set using `smocks.connection('label')` where label is the name\nof the connection.\n\nThis is useful for where smocks is setup as a plugin.\n\nExample:\n``` javascript\n\nvar hapi = require('hapi');\nvar smocks = require('smocks');\nvar server = new hapi.Server();\nserver.connection({ port: 8080, labels: 'main' });\nserver.connection({ port: 8088, labels: 'smocks' });\nserver.connection({ port: 8089, labels: 'mockhost1' });\n\nsmocks.id('example'); // must set\nsmocks.connection('smocks');\n\nvar plugin = require('smocks/hapi').toPlugin({\n    onRegister: (server, options, next) => {\n\n         smocks.route({\n            id: 'counter',\n            connection: 'mockhost1',\n            method: 'GET',\n            path: '/',\n            label: 'Simple get',\n            handler: function (request, reply) {\n                return reply('you got!');\n            }\n         });\n        return next();\n    }\n});\n\nserver.register({ register: plugin, options: {} }, function (err) {\n    server.start(function () {\n        // ..\n    });\n});\n\n```\n\nThis way the main server is not affected by the smocks routes, and there is no\nrisk of endpoint collision. Here all the admin connections are on the admin\nconnection, and the mocked host is on it's own. This is useful when mocking\nexternal hosts that the code may rely on.\n\nWhen a connection is not explicitly defined, the smocks routes will show up on\n_ALL_ connections.","title":"Connections","sections":[]},{"body":"Using the Admin Panel, you can save all route, variant and input settings as a \"profile\".  Profiles can either be saved locally (using localStorage) or remotely by providing the code to update in your project.\n\nThe profiles can also be changed using an admin endpoint (for example, to use this with an automated testing solution).  To do so, simply POST to {host}:{port}/api/profile/{profile name}.\n\nGlobal profiles can be set applied to the ```smocks``` object.  The easiest way to do this is to make your changes in the admin panel, enter the ```Profile Name``` in the settings header, and click the ```for everyone``` button.  You will be provided with the code that is necessary for the provide to be loaded globally.\n\n![profile example](http://jhudson8.github.io/smocks/images/profile-ex1.png)","title":"Profiles","sections":[]}]},{"body":"_reset the state_\nPOST to ```{host}:{port}/api/state/reset```\n\n_set an active route variant_\nPOST to ```{host}:{port}/api/route/{routeId}``` with body content ```{ variant: _variant id_ }```\n\n_select a profile_\nPOST to ```/api/profile/{profile name}```","title":"RESTful admin API","sections":[]},{"body":"Using [Google Chrome](http://www.google.com/chrome/) and other browsers, you can create a [HAR](https://en.wikipedia.org/wiki/.har) file which is basically a recording of the network activity during your session.\n\nThe smocks server has the ability to upload a [HAR](https://en.wikipedia.org/wiki/.har) file and reply the exact payloads as seen in the browsing session.  This is intended to only be used with a RESTful API and has the following caviats\n\n* Only the `.json` responses will be recorded\n* The HAR response will be rendered as long as the path and method match (query parameters and request payload are not evaluated)\n* Network calls defined in the HAR but are not defined with the Smocks server will return a 404\n\nClick the ***Har Replay*** tab to upload a HAR file\n\n![profile example](http://jhudson8.github.io/smocks/images/har-empty.png)\n\nDrag and drop your HAR file into the `HTTP Archive Upload` box\n\n![profile example](http://jhudson8.github.io/smocks/images/har-uploaded.png)\n\nThere may be cases where you need to alter the URL of what is in the `.har` file to match what the\nmock server will respond to.  These can be set as `pathMapper` in the `har` options when starting the smocks server\n```\nrequire('smocks/hapi').start({\n  // hapi options\n}, {\n  // smocks options\n  har: {\n    pathMapper: function (path) {\n      if (pathFromHarShouldBeReturned) {\n        return convertPathInSomeWay(path); // or leave as-is\n      }\n      // if nothing is returned, the mock server will just respond\n      // normally to what would represent this path\n    }\n  },\n```","title":"HTTP Archive Replay","sections":[]},{"body":"You can use smocks to be a straight proxy to another server.  To do so, you must provide the proxy details in the hapi start options.\nn\n```\nrequire('smocks/hapi').start({\n  // hapi options\n  port: 8000,\n  host: 'localhost',\n}, {\n  // smocks options\n  proxy: {\n    '{key shown in admin panel}': '{fully qualified endpoint prefix before the request path}',\n    // example\n    'google': 'http://www.google.com'\n    // or, using a function\n    'google': function (request) {\n      return ...\n    }\n  }\n});\n```\n\nView the `Config` tab on the admin panel to make any proxy setting changes.","title":"Proxying","sections":[]},{"body":"The user application state handler is pluggable.  To assign a new state impl to your smocks server, use the `state` smocks option.\n\n```\nrequire('smocks').start({\n    // hapi options\n  }, {\n   // smocks options\n   state: myStateImpl\n  });\n```\n\nThe state object must have the following methods (the can be instance prototype methods or simple object methods).\n\n| attribute | parameters | comments |\n|-----------|------------|----------|\n| initialize | (request, callback) | called at the beginning of each request; callback must be called with (err, value);  value = true if initialization needs to happen, false if the session has already been initialized\n| userState | (request, options) | return the user application state object.  `options` object contains `route` and `variant` attributes\n| resetUserState | {request, initialState) | reset the complete application state to be the initial state (no need to clone object);  this is also called if `initialize` callback is executed with `true`.\n| routeState | (request) | return the state object used to contain all admin panel route config changes\n| resetRouteState | (request) | reset the state object","title":"Pluggable State Handler","sections":[]}],"api":{"Route Config Objects":{"methods":{},"packages":{"Smocks":{"overview":"This refers to functions which can be executed from the `smocks` object.","methods":{"route":{"profiles":["options"],"params":{"options":"object containing the following values","path":"the route path (must start with ```/```).  Ex: ```/api/customer/{id}```","label":"An optional human readable label that can be seen in the admin panel for this route","method":"optional method (GET is default)","handler":"optional default route handler (same as the first variant applied to this route)"},"summary":"Refer to the [route docs](#link/%23project%2Fjhudson8%2Fsmocks%2Fsection%2FConcepts%2FRoutes) for more details.","dependsOn":[],"overview":""},"plugin":{"profiles":["plugin"],"params":{"plugin":"the plugin object"},"summary":"Refer to the [plugin docs](#link/%23project%2Fjhudson8%2Fsmocks%2Fsection%2FConcepts%2FPlugins) for more details.","dependsOn":[],"overview":""},"start":{"profiles":["options"],"params":{"options":"either object {host, port} or a HAPI server instance"},"summary":"Start a HAPI server with the defined mock configuration.","dependsOn":[],"overview":"Both the host and port are optional and will default to ```localhost``` and ```8080```.\n\nIf a HAPI server instance is provided, the routes will be bound to the HAPI server provided but the ```start``` method will not be called."}}},"Route":{"overview":"","methods":{"route":{"profiles":["options"],"params":{},"summary":"Object returned when calling [smocks.route](#link/%23project%2Ftmp%2Fsmocks%2Fmethod%2Fglobal%2Froute)","dependsOn":[],"overview":"Refer to the [route docs](#project/jhudson8/smocks/section/Concepts/Routes) for more details."},"input":{"profiles":["attributes"],"params":{"attributes":"The input attributes"},"summary":"Set any input attributes that will be available for modification on the admin panel.","dependsOn":[],"overview":"See [config example](#project/jhudson8/smocks/section/Examples/Route%20%2F%20variant%20input) for details.\n\nReturn the same route object for chaining.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({\n      ...\n      input: {\n        myVar: {\n          label: 'Input label',\n          type: 'boolean|text|select|multiselect',\n          defaultValue: ...\n        }\n      })\n      .respondWith(...)\n```"},"variant":{"profiles":["id"],"params":{"id":"the variant id"},"summary":"Set up a new route variant with the provided id.  The id is meaningful when selecting the active variant from the admin panel.","dependsOn":[],"overview":"A variant is basically a single request handler for a defined route.  This is useful to test out different scenarios for a single route definition.\n\nReturn the [Variant object](#project/jhudson8/smocks/snippet/package/Variant) for chaining.\n\nRefer to the [variant docs](#project/jhudson8/smocks/section/Concepts/Variants) for more details.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route(...)\n    .variant('respond like this').respondWith(...)\n    .variant('respond like that').respondWith(...)\n```"},"plugin":{"profiles":["plugin"],"params":{},"summary":"Refer to [global:plugin](#link/%23project%2Fjhudson8%2Fsmocks%2Fsnippet%2Fmethod%2Fglobal%2Fplugin)","dependsOn":[],"overview":""},"respondWith":{"profiles":["requestHandler"],"params":{"requestHandler":"The [RequestHandler](#project/jhudson8/smocks/section/Object%20Types/RequestHandler)"},"summary":"Convienance method for creating a default variant (id of \"default\") and then calling [Variant:respondWith](#link/%23project%2Fjhudson8%2Fsmocks%2Fsnippet%2Fmethod%2FVariant%2FrespondWith) on the variant.","dependsOn":[],"overview":""},"respondWithFile":{"profiles":["filePath"],"params":{},"summary":"Convienance method for creating a default variant (id of \"default\") and then calling [Variant:respondWithFile](#link/%23project%2Fjhudson8%2Fsmocks%2Fsnippet%2Fmethod%2FVariant%2FrespondWithFile) on the variant.","dependsOn":[],"overview":""}}},"Variant":{"overview":"Object returned when calling [Route.variant](#project/tmp/smocks/method/smocks.route/variant)\n\nRefer to the [route docs](#link/%23project%2Fjhudson8%2Fsmocks%2Fsection%2FConcepts%2FVariants) for more details.","methods":{"route":{"profiles":["options"],"params":{},"summary":"Refer to [global:route](#link/%23project%2Fjhudson8%2Fsmocks%2Fsnippet%2Fmethod%2Fglobal%2Froute)","dependsOn":[],"overview":""},"input":{"profiles":["attributes"],"params":{"attributes":"The input attributes"},"summary":"Set any variant-scoped input attributes that will be available for modification on the admin panel.","dependsOn":[],"overview":"See [input example](#project/jhudson8/smocks/section/Examples/Route%20%2F%20variant%input) for details.\n\nReturn the same Variant object for chaining."},"variant":{"profiles":["id"],"params":{},"summary":"Refer to [Route:variant](#link/l%23project%2Fjhudson8%2Fsmocks%2Fsnippet%2Fmethod%2FRoute%2Fvariant)","dependsOn":[],"overview":""},"plugin":{"profiles":["plugin"],"params":{},"summary":"Refer to [global:plugin](#link/%23project%2Fjhudson8%2Fsmocks%2Fsnippet%2Fmethod%2Fglobal%2Fplugin)","dependsOn":[],"overview":""},"respondWith":{"profiles":["requestHandler"],"params":{"requestHandler":"The [RequestHandler](#project/jhudson8/smocks/section/Object%20Types/RequestHandler)"},"summary":"Associate a request handler with the current route/method/variant combination.","dependsOn":[],"overview":"Return the same Variant object for chaining.\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route(...).respondWith(function(request, reply) {\n      var theMessage = request.params.message;\n      var aQueryStringValue = request.query.theQueryStringKey;\n      reply({message: theMessage}); // reply with a JSON payload\n      // or reply with something else\n      reply({error: {message: 'Some unknown error'}}).code(500);\n    });\n```"},"respondWithFile":{"profiles":["options"],"params":{"options":"options or the path name as a string"},"summary":"Option can include\n* ***code***: http status code\n* ***path***: the file path which can include route token references","dependsOn":[],"overview":"Remember that using ```./``` will refer to the top level module directory (the directory where ```node_modules``` exists regardless of the location of the file that is referring to a file location with ```./```);\n\n```javascript\n    var smocks = require('smocks');\n    smocks.route({path: '/customer/{id}'}).respondWithFile('./customer-{id}.json')\n    .start(...)\n```\n\nThis would cause a request to ```/customer/1``` to return the file ```./customer-1.json```\n\nIf the `path` option is not provided a custom file handler provided as a smocks option as `respondWithFileHandler` will be used.  This is a function which takes a single object parameter which contains\n* ***request***: the HAPI request object\n* ***response***: the HAPI response object\n* ***route***: the route object\n* ***variant***: the variant object\n* ***options***: the options object passed to the `respondWithFile` function\n* ***smocksOptions: the smocks options object\n\n```\n// smocks start code\nsmocks.start({\n  port: 8000,\n  host: 'localhost',\n}, {\n  respondWithFileHandler: function(data) {\n    // example file handler\n    var reply = data.reply;\n    var code = data.options.code || 200;\n    var route = data.route;\n    var path = route.path().replace(/\\{\\}/g, '');\n    var variant = data.variant;\n    var filePath = // create file path from all this data\n    fs.readFile(function (err, stream) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n     return reply().code(404);\n        } else {\n     return reply(err);\n        }\n      }\n      reply(stream).type('application/json').code(code);\n    });\n  }\n});\n```"}}}}},"Pseudo Database":{"methods":{},"packages":{"smocks.db":{"overview":"Smocks has a database-like object which can be used to store data in state in a why that makes data querying and normalization easy.\nYou can access this object at any time during the event loop of a current request using ```require('smocks').db```.\nBy default the smocks `state` object will be used to persist the data but that can be changed at the domain (AKA database table) level.","methods":{"insert":{"profiles":["domain, object"],"params":{"domain":"the top level store attribute that will contain this object","object":"the object to insert.  If the object does not have an `id` attribute, a uuid will be created.  (the attribute can be changed using the ***init*** function)"},"summary":"Insert an object into the \"table\".  The object will be returned.","dependsOn":[],"overview":"```\nvar db = require('smocks').db;\n\n// of `object` doesn't contain an id a uuid will be set\nvar insertedObject = db.insert('foo', object);\n```"},"get":{"profiles":["domain, id"],"params":{"domain":"the top level store attribute that will contain this object","id":"the object id"},"summary":"Return an object from the \"table\" identified by the provided id.","dependsOn":[],"overview":"```\nvar db = require('smocks').db;\n\nvar object = db.get('foo', 'some_id');\n```"},"delete":{"profiles":["domain, id"],"params":{"domain":"the top level store attribute that will contain this object","id":"the object id"},"summary":"Delete and an object from the \"table\" identified by the provided id.  The deleted object will be returned.","dependsOn":[],"overview":"```\nvar db = require('smocks').db;\n\nvar deletedObject = db.delete('foo', 'some_id');\n```"},"update":{"profiles":["domain, idOrObject[, object]"],"params":{"domain":"the top level store attribute that will contain this object","idOrObject":"the object id or the object contents to update","object":"(if `idOrObject` is an id) the object contents to be updated"},"summary":"Update an existing object in the \"table\" identified by the provided id.","dependsOn":[],"overview":"if the id is provided as the `idOrObject` with a separate object provided as the `object` parameter, the existing contents will only have individual fields updated identified by the provided object.\n\nif the object is provided as the `idOrObject` (so only 2 function parameters) then the entire object will be replaced.\n\n```\nvar db = require('smocks').db;\n\n// this will only overwrite the attributes provided as the 3rd parameter\nvar updatedObject = db.update('foo', 'some_id', data);\n\n// this will completely overwrite the stored object.  `newObject` must have an id\nvar updatedObject = db.update('foo', newObject);\n```"},"insertOrUpdate":{"profiles":["domain, object"],"params":{"domain":"the top level store attribute that will contain this object","object":"the object to insert or update.  If the object does not have an `id` attribute, a uuid will be created.  (the attribute can be changed using the ***init*** function)"},"summary":"Either inserts or updates an object depending on whether it already exists.  Using ***update*** alone will throw an Error if no object can be found matching the provided id.","dependsOn":[],"overview":"```\nvar db = require('smocks').db;\n\nvar insertedOrUpdatedObject = db.insertOrUpdate('foo', object);\n```"},"meta":{"profiles":["domain, id, object"],"params":{"domain":"the top level store attribute that will contain this object","id":"the object id","object":"meta contents.  If `false`, delete existing metadata.  If `undefined`, return the existing metadata.  If an object, replace the existing metadata."},"summary":"Store arbitrary object data which is kept separately from the object itself.","dependsOn":[],"overview":"```\nvar db = require('smocks').db;\n\nvar insertedObject = db.insert('foo', object);\n\n// this data will not be accessable from `insertedObject` directly\ndb.meta('foo', insertedObject.id, { abc: 'def' });\n\n// meta will be { abc: 'def' }\nvar meta = db.meta('foo', insertedObject.id);\n```"},"list":{"profiles":["domain"],"params":{"domain":"the top level store attribute"},"summary":"Return an object which will return the contents of the \"table\" as an array using the `result` function","dependsOn":[],"overview":"```\nvar fooItems = db.list('foo').result();\n```\n\nThe returned object has several additional helper methods which can be chained\n##### filter(criteria)\n* ***criteria***: the filter criteria\n\nFilter the results using the provided criteria.  The criteria can be\n* a function which accepts a domain object and returns a truthy if the item should be included\n* an object with key/values that should match domain object values (key an value paths can use \".\" for nesting)\n* the previous object but with functions for values.  The function parameter is the value from the object identified by the key\n\n```\n// the following statements do the same thing\nvar filteredArray = db.list('foo').filter(function (object) { return object.nested.abc === 'def'; }).result();\nvar filteredArray = db.list('foo').filter({ 'nested.abc': function (value) { return value === 'def'; }}).result();\nvar filteredArray = db.list('foo').filter({ 'nested.abc': 'def' }).result();\n```\n\n##### sort(comparator, ascending)\n* ***comparator***: a string representing the attribute name or a `Array.sort` comparator function\n* ***ascending***: if `comparator` is a strong, true for ascending and false for descending (default is true)\n\n```\n// the following statements do the same thing\nvar sortedArray = db.list('foo').sort('nested.abc', false).result();\nvar sortedArray = db.list('foo').sort(function (a, b) { return a.nested.abc > b.nested.abc ? -1 : 1; }).result();\n```\n\n##### limit(offset, size)\n* ***offset***: 0-based starting point offset\n* ***size***: maximum number of results to return\n\nReturn a limited set of results from the main set\n```\n// the following will only return the first 5 entries\nvar limitedArray = db.list('foo').limit(0, 5).result();\n```\nWhen using limit, you may want to know the original size of the array.  You can use the `data` function for that (see below).\n\n##### data()\n\nReturn an object containing the results as `result` attribute with additional attributes.\n\n* ***filtered***: `true` if the results have been filtered\n* ***sorted***: `true` if the results have been sorted\n* ***totalCount***: if the results were limited using the `limit` function, the total itme count ***before** limit was called\n* ***offset***: the `offset` value provided to `limit` if applicable\n* ***size***: the `size` value provided to `limit` if applicable\n* ***result***: the same value as if you had called `result()`"}}}}}}});
